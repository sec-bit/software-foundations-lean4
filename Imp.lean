-- ------------------ ARITHMETIC AND BOOLEAN EXPRESSIONS -----------------------

-- Arithmetic expressions
inductive AExp : Type where
  | ANum (n : Nat)
  | APlus (a1 a2 : AExp)
  | AMinus (a1 a2 : AExp)
  | AMult (a1 a2 : AExp)

-- Boolean expressions
inductive BExp : Type where
  | BTrue
  | BFalse
  | BEq (a1 a2 : AExp)
  | BNeq (a1 a2 : AExp)
  | BLe (a1 a2 : AExp)
  | BGt (a1 a2 : AExp)
  | BNot (b : BExp)
  | BAnd (b1 b2 : BExp)

open AExp BExp

-- ------------------ EVALUATION -----------------------

-- Evaluate arithmetic expression to Nat
def aeval (a : AExp) : Nat :=
  match a with
  | ANum n => n
  | APlus a1 a2 => aeval a1 + aeval a2
  | AMinus a1 a2 => aeval a1 - aeval a2
  | AMult a1 a2 => aeval a1 * aeval a2

example : aeval (APlus (ANum 2) (ANum 2)) = 4 := rfl

-- Evaluate boolean expression to Bool
-- Coq: =? is Nat.eqb, <=? is Nat.leb, negb is !, andb is &&
def beval (b : BExp) : Bool :=
  match b with
  | BTrue => true
  | BFalse => false
  | BExp.BEq a1 a2 => aeval a1 == aeval a2
  | BNeq a1 a2 => !(aeval a1 == aeval a2)
  | BLe a1 a2 => aeval a1 ≤ aeval a2   -- Nat has Decidable LE, returns Bool in this context
  | BGt a1 a2 => !(aeval a1 ≤ aeval a2)
  | BNot b1 => !beval b1
  | BAnd b1 b2 => beval b1 && beval b2

-- ------------------ OPTIMIZATION -----------------------

-- Remove 0 + e, replacing with just e
def optimize_0plus (a : AExp) : AExp :=
  match a with
  | ANum n => ANum n
  | APlus (ANum 0) e2 => optimize_0plus e2
  | APlus e1 e2 => APlus (optimize_0plus e1) (optimize_0plus e2)
  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)
  | AMult e1 e2 => AMult (optimize_0plus e1) (optimize_0plus e2)

example : optimize_0plus (APlus (ANum 2)
                           (APlus (ANum 0)
                             (APlus (ANum 0) (ANum 1))))
          = APlus (ANum 2) (ANum 1) := rfl

theorem optimize_0plus_sound (a : AExp) : aeval (optimize_0plus a) = aeval a := by
  induction a with
  | ANum n => rfl
  | APlus a1 a2 IHa1 IHa2 =>
    cases a1 with
    | ANum n =>
      cases n with
      | zero => simp_all [optimize_0plus, aeval]
      | succ n => simp_all [optimize_0plus, aeval]
    | APlus _ _ => simp_all [optimize_0plus, aeval]
    | AMinus _ _ => simp_all [optimize_0plus, aeval]
    | AMult _ _ => simp_all [optimize_0plus, aeval]
  | AMinus a1 a2 IHa1 IHa2 => simp_all [optimize_0plus, aeval]
  | AMult a1 a2 IHa1 IHa2 => simp_all [optimize_0plus, aeval]


-- ------------------ ROCQ AUTOMATION -----------------------

-- Coq's `try T` = Lean's `try T`
-- If T fails, `try T` does nothing instead of failing

theorem silly1 (P : Prop) (HP : P) : P := by
  try rfl  -- would fail, but try catches it
  exact HP

theorem silly2 (ae : AExp) : aeval ae = aeval ae := by
  try rfl  -- succeeds

-- Coq's `T1; T2` applies T2 to all goals generated by T1
-- Lean's `<;>` does the same
theorem foo (n : Nat) : (0 ≤ n) = true := by
  cases n
  · simp
  · simp

theorem foo' (n : Nat) : (0 ≤ n) = true := by
  cases n <;> simp

theorem optimize_0plus_sound' (a : AExp) : aeval (optimize_0plus a) = aeval a := by
  induction a with
  | ANum n => rfl
  | APlus a1 a2 IHa1 IHa2 =>
    cases a1 with
    | ANum n => cases n <;> simp_all [optimize_0plus, aeval]
    | _ => simp_all [optimize_0plus, aeval]
  | _ => simp_all [optimize_0plus, aeval]

-- ------------------ THE REPEAT TACTICAL -----------------------

-- Coq's `repeat T` keeps applying T until it fails
-- Lean's `repeat T` does the same

-- List membership: Lean uses `∈` for List.Mem
theorem In10 : 10 ∈ [1,2,3,4,5,6,7,8,9,10] := by
  repeat (first | exact List.Mem.head _ | apply List.Mem.tail)

-- Alternative
theorem In10' : 10 ∈ [1,2,3,4,5,6,7,8,9,10] := by
  decide  -- Lean can just compute this

-- Warning: repeat with a tactic that always succeeds will loop forever
-- theorem repeat_loop (m n : Nat) : m + n = n + m := by
--   repeat rw [Nat.add_comm]  -- infinite loop!


def optimize_0plus_b (b : BExp) : BExp :=
  match b with
  | BTrue => BTrue
  | BFalse => BFalse
  | BExp.BEq a1 a2 => BEq (optimize_0plus a1) (optimize_0plus a2)
  | BNeq a1 a2 => BNeq (optimize_0plus a1) (optimize_0plus a2)
  | BLe a1 a2 => BLe (optimize_0plus a1) (optimize_0plus a2)
  | BGt a1 a2 => BGt (optimize_0plus a1) (optimize_0plus a2)
  | BNot b1 => BNot (optimize_0plus_b b1)
  | BAnd b1 b2 => BAnd (optimize_0plus_b b1) (optimize_0plus_b b2)

example : optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8)))
        = BNot (BGt (ANum 4) (ANum 8)) := rfl

example : optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue)
        = BAnd (BLe (ANum 4) (ANum 5)) BTrue := rfl

theorem optimize_0plus_b_sound (b : BExp) : beval (optimize_0plus_b b) = beval b := by
  induction b with
  | BTrue => rfl
  | BFalse => rfl
  | BEq a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BNeq a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BLe a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BGt a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BNot b1 IHb1 => simp [optimize_0plus_b, beval, IHb1]
  | BAnd b1 b2 IHb1 IHb2 => simp [optimize_0plus_b, beval, IHb1, IHb2]

-- ------------------ DEFINING NEW TACTICS -----------------------

-- Coq's `Ltac invert H := inversion H; subst; clear H`
-- Lean uses macros to define custom tactics
macro "invert" h:ident : tactic =>
  `(tactic| (cases $h:ident; subst_vars))

theorem invert_example1 (a b c : Nat) (H : [a, b] = [a, c]) : b = c := by
  invert H
  rfl

-- ------------------ THE OMEGA TACTIC -----------------------

-- Coq's `lia` is Lean's `omega`
example (m n o p : Nat) (H : m + n ≤ n + o ∧ o + 3 = p + 3) : m ≤ p := by
  omega

example (m n : Nat) : m + n = n + m := by
  omega

example (m n p : Nat) : m + (n + p) = m + n + p := by
  omega

-- ------------------ EVALUATION AS A RELATION -----------------------

-- Instead of a function aeval : AExp → Nat, define a relation
-- aevalR : AExp → Nat → Prop

inductive AEvalR : AExp → Nat → Prop where
  | E_ANum (n : Nat) : AEvalR (ANum n) n
  | E_APlus (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → AEvalR (APlus e1 e2) (n1 + n2)
  | E_AMinus (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → AEvalR (AMinus e1 e2) (n1 - n2)
  | E_AMult (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → AEvalR (AMult e1 e2) (n1 * n2)

-- Notation: Coq uses `e ==> n`, we use infix
infix:50 " ==> " => AEvalR

-- ------------------ EQUIVALENCE OF DEFINITIONS -----------------------

theorem aevalR_iff_aeval (a : AExp) (n : Nat) : (a ==> n) ↔ aeval a = n := by
  constructor
  -- → direction: relation implies function
  · intro H
    induction H with
    | E_ANum n => rfl
    | E_APlus _ _ _ _ _ _ IH1 IH2 => simp [aeval, IH1, IH2]
    | E_AMinus _ _ _ _ _ _ IH1 IH2 => simp [aeval, IH1, IH2]
    | E_AMult _ _ _ _ _ _ IH1 IH2 => simp [aeval, IH1, IH2]
  -- ← direction: function implies relation
  · intro H
    induction a generalizing n with
    | ANum m => simp [aeval] at H; subst H; exact AEvalR.E_ANum m
    | APlus a1 a2 IH1 IH2 =>
      simp [aeval] at H; subst H
      exact AEvalR.E_APlus a1 a2 _ _ (IH1 _ rfl) (IH2 _ rfl)
    | AMinus a1 a2 IH1 IH2 =>
      simp [aeval] at H; subst H
      exact AEvalR.E_AMinus a1 a2 _ _ (IH1 _ rfl) (IH2 _ rfl)
    | AMult a1 a2 IH1 IH2 =>
      simp [aeval] at H; subst H
      exact AEvalR.E_AMult a1 a2 _ _ (IH1 _ rfl) (IH2 _ rfl)

-- ------------------ BOOLEAN EVALUATION RELATION -----------------------

inductive BEvalR : BExp → Bool → Prop where
  | E_BTrue : BEvalR BTrue true
  | E_BFalse : BEvalR BFalse false
  | E_BEq (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → BEvalR (BEq e1 e2) (n1 == n2)
  | E_BNeq (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → BEvalR (BNeq e1 e2) (!(n1 == n2))
  | E_BLe (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → BEvalR (BLe e1 e2) (decide (n1 ≤ n2))
  | E_BGt (e1 e2 : AExp) (n1 n2 : Nat) :
      AEvalR e1 n1 → AEvalR e2 n2 → BEvalR (BGt e1 e2) (!(decide (n1 ≤ n2)))
  | E_BNot (e : BExp) (b : Bool) :
      BEvalR e b → BEvalR (BNot e) (!b)
  | E_BAnd (e1 e2 : BExp) (b1 b2 : Bool) :
      BEvalR e1 b1 → BEvalR e2 b2 → BEvalR (BAnd e1 e2) (b1 && b2)

infix:50 " ==>b " => BEvalR

theorem bevalR_iff_beval (b : BExp) (bv : Bool) : (b ==>b bv) ↔ beval b = bv := by
  constructor
  · intro H
    induction H with
    | E_BTrue => rfl
    | E_BFalse => rfl
    | E_BEq _ _ n1 n2 H1 H2 =>
      simp [beval, (aevalR_iff_aeval _ _).mp H1, (aevalR_iff_aeval _ _).mp H2]
    | E_BNeq _ _ n1 n2 H1 H2 =>
      simp [beval, (aevalR_iff_aeval _ _).mp H1, (aevalR_iff_aeval _ _).mp H2]
    | E_BLe _ _ n1 n2 H1 H2 =>
      simp [beval, (aevalR_iff_aeval _ _).mp H1, (aevalR_iff_aeval _ _).mp H2]
    | E_BGt _ _ n1 n2 H1 H2 =>
      simp [beval, (aevalR_iff_aeval _ _).mp H1, (aevalR_iff_aeval _ _).mp H2]
    | E_BNot _ _ _ IH => simp [beval, IH]
    | E_BAnd _ _ _ _ _ _ IH1 IH2 => simp [beval, IH1, IH2]
  · intro H
    induction b generalizing bv with
    | BTrue => simp [beval] at H; subst H; exact BEvalR.E_BTrue
    | BFalse => simp [beval] at H; subst H; exact BEvalR.E_BFalse
    | BEq a1 a2 =>
      simp [beval] at H; subst H
      exact BEvalR.E_BEq a1 a2 _ _ ((aevalR_iff_aeval _ _).mpr rfl) ((aevalR_iff_aeval _ _).mpr rfl)
    | BNeq a1 a2 =>
      rw [← H]
      exact BEvalR.E_BNeq a1 a2 _ _ ((aevalR_iff_aeval _ _).mpr rfl) ((aevalR_iff_aeval _ _).mpr rfl)
    | BLe a1 a2 =>
      simp [beval] at H; rw [← H]
      exact BEvalR.E_BLe a1 a2 _ _ ((aevalR_iff_aeval _ _).mpr rfl) ((aevalR_iff_aeval _ _).mpr rfl)
    | BGt a1 a2 =>
      rw [← H]
      exact BEvalR.E_BGt a1 a2 _ _ ((aevalR_iff_aeval _ _).mpr rfl) ((aevalR_iff_aeval _ _).mpr rfl)
    | BNot b1 IH =>
      rw [← H]
      exact BEvalR.E_BNot b1 _ (IH _ rfl)
    | BAnd b1 b2 IH1 IH2 =>
      simp [beval] at H; subst H
      exact BEvalR.E_BAnd b1 b2 _ _ (IH1 _ rfl) (IH2 _ rfl)

-- ------------------ COMPUTATIONAL VS RELATIONAL DEFINITIONS -----------------------

-- Example: Adding division - hard with functions (what is 5/0?), easy with relations

namespace AEvalR_Division

inductive AExp' : Type where
  | ANum (n : Nat)
  | APlus (a1 a2 : AExp')
  | AMinus (a1 a2 : AExp')
  | AMult (a1 a2 : AExp')
  | ADiv (a1 a2 : AExp')  -- NEW

open AExp'

inductive AEvalR' : AExp' → Nat → Prop where
  | E_ANum (n : Nat) : AEvalR' (ANum n) n
  | E_APlus (a1 a2 : AExp') (n1 n2 : Nat) :
      AEvalR' a1 n1 → AEvalR' a2 n2 → AEvalR' (APlus a1 a2) (n1 + n2)
  | E_AMinus (a1 a2 : AExp') (n1 n2 : Nat) :
      AEvalR' a1 n1 → AEvalR' a2 n2 → AEvalR' (AMinus a1 a2) (n1 - n2)
  | E_AMult (a1 a2 : AExp') (n1 n2 : Nat) :
      AEvalR' a1 n1 → AEvalR' a2 n2 → AEvalR' (AMult a1 a2) (n1 * n2)
  | E_ADiv (a1 a2 : AExp') (n1 n2 n3 : Nat) :  -- NEW
      AEvalR' a1 n1 → AEvalR' a2 n2 → n2 > 0 → n2 * n3 = n1 → AEvalR' (ADiv a1 a2) n3

-- This relation is partial: ADiv (ANum 5) (ANum 0) has no evaluation

end AEvalR_Division

-- Example: Nondeterminism - impossible with functions, easy with relations

namespace AEvalR_Extended

inductive AExp'' : Type where
  | AAny            -- NEW: evaluates to any number
  | ANum (n : Nat)
  | APlus (a1 a2 : AExp'')
  | AMinus (a1 a2 : AExp'')
  | AMult (a1 a2 : AExp'')

open AExp''

inductive AEvalR'' : AExp'' → Nat → Prop where
  | E_Any (n : Nat) : AEvalR'' AAny n  -- NEW: any n is valid
  | E_ANum (n : Nat) : AEvalR'' (ANum n) n
  | E_APlus (a1 a2 : AExp'') (n1 n2 : Nat) :
      AEvalR'' a1 n1 → AEvalR'' a2 n2 → AEvalR'' (APlus a1 a2) (n1 + n2)
  | E_AMinus (a1 a2 : AExp'') (n1 n2 : Nat) :
      AEvalR'' a1 n1 → AEvalR'' a2 n2 → AEvalR'' (AMinus a1 a2) (n1 - n2)
  | E_AMult (a1 a2 : AExp'') (n1 n2 : Nat) :
      AEvalR'' a1 n1 → AEvalR'' a2 n2 → AEvalR'' (AMult a1 a2) (n1 * n2)

-- AAny can evaluate to any natural number - nondeterministic

end AEvalR_Extended
