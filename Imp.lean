-- ------------------ ARITHMETIC AND BOOLEAN EXPRESSIONS -----------------------

-- Arithmetic expressions
inductive AExp : Type where
  | ANum (n : Nat)
  | APlus (a1 a2 : AExp)
  | AMinus (a1 a2 : AExp)
  | AMult (a1 a2 : AExp)

-- Boolean expressions
inductive BExp : Type where
  | BTrue
  | BFalse
  | BEq (a1 a2 : AExp)
  | BNeq (a1 a2 : AExp)
  | BLe (a1 a2 : AExp)
  | BGt (a1 a2 : AExp)
  | BNot (b : BExp)
  | BAnd (b1 b2 : BExp)

open AExp BExp

-- ------------------ EVALUATION -----------------------

-- Evaluate arithmetic expression to Nat
def aeval (a : AExp) : Nat :=
  match a with
  | ANum n => n
  | APlus a1 a2 => aeval a1 + aeval a2
  | AMinus a1 a2 => aeval a1 - aeval a2
  | AMult a1 a2 => aeval a1 * aeval a2

example : aeval (APlus (ANum 2) (ANum 2)) = 4 := rfl

-- Evaluate boolean expression to Bool
-- Coq: =? is Nat.eqb, <=? is Nat.leb, negb is !, andb is &&
def beval (b : BExp) : Bool :=
  match b with
  | BTrue => true
  | BFalse => false
  | BExp.BEq a1 a2 => aeval a1 == aeval a2
  | BNeq a1 a2 => !(aeval a1 == aeval a2)
  | BLe a1 a2 => aeval a1 ≤ aeval a2   -- Nat has Decidable LE, returns Bool in this context
  | BGt a1 a2 => !(aeval a1 ≤ aeval a2)
  | BNot b1 => !beval b1
  | BAnd b1 b2 => beval b1 && beval b2

-- ------------------ OPTIMIZATION -----------------------

-- Remove 0 + e, replacing with just e
def optimize_0plus (a : AExp) : AExp :=
  match a with
  | ANum n => ANum n
  | APlus (ANum 0) e2 => optimize_0plus e2
  | APlus e1 e2 => APlus (optimize_0plus e1) (optimize_0plus e2)
  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)
  | AMult e1 e2 => AMult (optimize_0plus e1) (optimize_0plus e2)

example : optimize_0plus (APlus (ANum 2)
                           (APlus (ANum 0)
                             (APlus (ANum 0) (ANum 1))))
          = APlus (ANum 2) (ANum 1) := rfl

theorem optimize_0plus_sound (a : AExp) : aeval (optimize_0plus a) = aeval a := by
  induction a with
  | ANum n => rfl
  | APlus a1 a2 IHa1 IHa2 =>
    cases a1 with
    | ANum n =>
      cases n with
      | zero => simp_all [optimize_0plus, aeval]
      | succ n => simp_all [optimize_0plus, aeval]
    | APlus _ _ => simp_all [optimize_0plus, aeval]
    | AMinus _ _ => simp_all [optimize_0plus, aeval]
    | AMult _ _ => simp_all [optimize_0plus, aeval]
  | AMinus a1 a2 IHa1 IHa2 => simp_all [optimize_0plus, aeval]
  | AMult a1 a2 IHa1 IHa2 => simp_all [optimize_0plus, aeval]


-- ------------------ ROCQ AUTOMATION -----------------------

-- Coq's `try T` = Lean's `try T`
-- If T fails, `try T` does nothing instead of failing

theorem silly1 (P : Prop) (HP : P) : P := by
  try rfl  -- would fail, but try catches it
  exact HP

theorem silly2 (ae : AExp) : aeval ae = aeval ae := by
  try rfl  -- succeeds

-- Coq's `T1; T2` applies T2 to all goals generated by T1
-- Lean's `<;>` does the same
theorem foo (n : Nat) : (0 ≤ n) = true := by
  cases n
  · simp
  · simp

theorem foo' (n : Nat) : (0 ≤ n) = true := by
  cases n <;> simp

theorem optimize_0plus_sound' (a : AExp) : aeval (optimize_0plus a) = aeval a := by
  induction a with
  | ANum n => rfl
  | APlus a1 a2 IHa1 IHa2 =>
    cases a1 with
    | ANum n => cases n <;> simp_all [optimize_0plus, aeval]
    | _ => simp_all [optimize_0plus, aeval]
  | _ => simp_all [optimize_0plus, aeval]

-- ------------------ THE REPEAT TACTICAL -----------------------

-- Coq's `repeat T` keeps applying T until it fails
-- Lean's `repeat T` does the same

-- List membership: Lean uses `∈` for List.Mem
theorem In10 : 10 ∈ [1,2,3,4,5,6,7,8,9,10] := by
  repeat (first | exact List.Mem.head _ | apply List.Mem.tail)

-- Alternative
theorem In10' : 10 ∈ [1,2,3,4,5,6,7,8,9,10] := by
  decide  -- Lean can just compute this

-- Warning: repeat with a tactic that always succeeds will loop forever
-- theorem repeat_loop (m n : Nat) : m + n = n + m := by
--   repeat rw [Nat.add_comm]  -- infinite loop!


def optimize_0plus_b (b : BExp) : BExp :=
  match b with
  | BTrue => BTrue
  | BFalse => BFalse
  | BExp.BEq a1 a2 => BEq (optimize_0plus a1) (optimize_0plus a2)
  | BNeq a1 a2 => BNeq (optimize_0plus a1) (optimize_0plus a2)
  | BLe a1 a2 => BLe (optimize_0plus a1) (optimize_0plus a2)
  | BGt a1 a2 => BGt (optimize_0plus a1) (optimize_0plus a2)
  | BNot b1 => BNot (optimize_0plus_b b1)
  | BAnd b1 b2 => BAnd (optimize_0plus_b b1) (optimize_0plus_b b2)

example : optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8)))
        = BNot (BGt (ANum 4) (ANum 8)) := rfl

example : optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue)
        = BAnd (BLe (ANum 4) (ANum 5)) BTrue := rfl

theorem optimize_0plus_b_sound (b : BExp) : beval (optimize_0plus_b b) = beval b := by
  induction b with
  | BTrue => rfl
  | BFalse => rfl
  | BEq a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BNeq a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BLe a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BGt a1 a2 => simp [optimize_0plus_b, beval, optimize_0plus_sound]
  | BNot b1 IHb1 => simp [optimize_0plus_b, beval, IHb1]
  | BAnd b1 b2 IHb1 IHb2 => simp [optimize_0plus_b, beval, IHb1, IHb2]

-- ------------------ DEFINING NEW TACTICS -----------------------

-- Coq's `Ltac invert H := inversion H; subst; clear H`
-- Lean uses macros to define custom tactics
macro "invert" h:ident : tactic =>
  `(tactic| (cases $h:ident; subst_vars))

theorem invert_example1 (a b c : Nat) (H : [a, b] = [a, c]) : b = c := by
  invert H
  rfl

-- ------------------ THE OMEGA TACTIC -----------------------

-- Coq's `lia` is Lean's `omega`
example (m n o p : Nat) (H : m + n ≤ n + o ∧ o + 3 = p + 3) : m ≤ p := by
  omega

example (m n : Nat) : m + n = n + m := by
  omega

example (m n p : Nat) : m + (n + p) = m + n + p := by
  omega
